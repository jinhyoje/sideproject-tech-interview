## HTTP/1.1 동작 방식
- HTTP/1.1은 기본적으로 Connection당 하나의 요청을 처리 하도록 설계
- 동시 전송이 불가능하고 요청과 응답이 순차적으로 이어짐
- HTTP 문서 안에 포함된 다수의 리소스(Image, CSS, Script)를 처리하려면 요청할 리소스 개수에 비례래서 대기시간이 길어짐

#### HTTP/1.1 단점
1. HOL (Head Of Line) Blocking 
    - 특정 응답의 지연
    - HOL 블로킹이란 네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다.

2. RTT( Round Trip Time ) 증가
    - 일반적으로 하나의 connection에 하나의 요청을 처리 
    - 그렇기 때문에 매 요청별로 connection을 만들게 되고 TCP상에서 동작하는 HTTP의 특성상 3-way Handshake 가 반복적으로 일어나고 또한 불필요한 RTT증가와 네트워크 지연을 초래하여 성능을 저하 시킴

3. 무거운 Header 구조
    - http/1.1의 헤더에는 많은 메타정보들을 저장 
    - 매 요청 시 마다 중복된 Header 값을 전송하게 되며(별도의 domain sharding을 하지 않았을 경우) 또한 해당 domain에 설정된 cookie 정보도 매 요청 시 마다 헤더에 포함되어 전송 
    - 전송하려는 값보다 헤더 값이 더 큰 경우도 자주 발생

#### HTTP/1.1 개선방법
1. Image Spriting
    - 웹 페이지를 구성하는 다양한 아이콘 이미지 파일의 요청 횟수를 줄이기 위해 아이콘을 하나의 큰 이미지로 만든 다음 CSS에서 해당 이미지의 좌표 값을 지정하여 표시하는 방법이다.
2. Domain Sharding
    - 브라우저들이 HTTP1.1의 단점을 극복하기 위해 여러 개의 Connection을 생성해서 병렬로 요청을 보내기도 한다. 하지만 브라우저 별로 도메인당 Connection 개수 제한이 존재하기 때문에 근복적인 해결은 어렵다.
3. Minified CSS/Javascript
    - HTTP를 통해 전송되는 데이터의 용량을 줄이기 위해 CSS, Javascript 코드를 축소한다.
4. Load Faster
    - 스타일시트를 HTML 문서 상위에 배치 
   스크립트를 HTML문서 하단에 배치
5. Data URI Scheme
    - HTML 문서 내 이미지 리소스를 Base64로 인코딩된 이미지 데이터로 직접 기술하는 방법으로, 서버로의 요청을 줄인다.
6. 구글의 SPDY
    - 위에서 언급된 노력들로는 근본적인 단점을 해결할 수 없었다. 그래서 구글은 더 빠른 웹을 실행하기 위해 Throughtput 관점이 아닌 Latency 관점에서 HTTP를 고속화한 SPDY(스피티)라 불리는 새로운 프로토콜을 구현했다. 
    - 다만 SPDY는 HTTP를 대체하는 프로토콜이 아니고 HTTP를 통한 전송을 재정의하는 형태로 구현되었다. 이는 HTTP2.0 초안의 참고 규격이 된다. 

## HTTP/2
- HTTP2.0은 HTTP1.1을 완전하게 재작성한 것이 아니라 프로토콜의 성능에 초첨을 맞춰 수정한 버전이라고 생각하면 된다.
- HTTP/2의 이진 프레임 레이어는 요청과 응답을 인코딩 하고 이를 더 작은 패킷으로 잘라 데이터 전송의 유연성을 향상 시킨다.

#### HTTP/2 주요 특징
1. Multiplexed Streams
    - 한 커넥션으로 동시에 여러 개의 메세지를 주고 받을 있으며, 응답은 순서에 상관없이 stream으로 주고 받음
2. Stream Prioritization
    -  리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결함
3. Server Push
    - 서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 보내줄 수 있음 
    - 클라이언트(브라우저)가 HTML문서를 요청하고 해당 HTML에 여러 개의 리소스(CSS, Image...) 가 포함되어 있는 경우 HTTP/1.1에서 클라이언트는 요청한 HTML문서를 수신한 후  HTML문서를 해석하면서 필요한 리소스를 재 요청하는 반면 HTTP/2에서는 Server Push기법을 통해서 클라이언트가 요청하지 않은 (HTML문서에 포함된 리소스) 리소스를 Push 해주는 방법으로 클라이언트의 요청을 최소화 해서 성능 향상을 이끌어 냄
4. Header Compression
    -  HTTP/2에서는 데이터에서 헤더를 분할하여 헤더 프레임과 데이터 프레임을 생성할 수 있다.
    - 그런다음 HTTP/2 전용 압축 프로그렘 HPACK이 헤더를 압축할 수 있다. 
    - 이 알고리즘은 Huffman coding을 사용하여 헤더 메타데이터를 인코딩할 수 있으므로 크기를 크게 줄일 수 있다.
    -  또한 HPACK은 이전에 전송된 메타데이터 필드를 추적하고, 클라이언트와 서버간에 공유된, 동적으로 변경된 인덱스에 따라서 해당 필드를 추가로 압축할 수 있다.

